<!doctype html>
<meta charset="utf-8">
<title>Barrish Calculator</title>
<link rel="stylesheet" href="reset.css">
<link rel="stylesheet" href="typebase.css">
<link rel="stylesheet" href="animate.css">
<link rel="stylesheet" href="whatnot.css">
<script src="lib/coffee-script.js"></script>
<script src="lib/jquery-2.1.4.js"></script>
<script src="helpers.coffee" type="text/coffeescript"></script>
<label>
	<h2>Input</h2>
	<textarea id="input">! sek ; ! /ng/ʌl.et ; ! te̞l.fɐl.e̞r.et ; bʉnd.et e̞n.krɘ.vɐ mʉt ɘn.se̞p.et jor./ng/on.sɘx ɐk /ng/a.mɐlk.sjɘd , lɘd.ɘ xe̞.dɘn lot.p̪ɘxt Se̞.lʌ ɐk ɐld o se̞les me̞.le̞s ; ja/ng/.et ɐk pe̞r.e̞n.se̞p.et s/ju/.ner.dɘ.lo/ng/ fʌr mɐs.jon ɐk op̪.e̞r.ʌ ɘn.dʌ s/ju/.fʉkt bɐ.sak , s/ju/or.sɐ.ke̞n le.nɐrt se.dʌn for.dɘ.bɘ.dɐt ; hɐr.set et.mɐ sʌm.de̞ fʌr /ng/ʌl.ve̞r.jɐn.mɐ.ja ɐk [p̪͡f]a.ve̞r.jɐn.et jed.mek , vol.vɘ.dɘt ɐv kɐ.vɐn.et bor.ɐ ; op̪.e̞r.ʌ.hɐrs.et ɐr.tʉs.ɘl fe̞r.mɐt ɐk fors.ɐ.le.for.hɐn.le̞n o fe̞r.mɐt ɐk fɘl.e̞s.kɐp.bɘst.e̞l ; sɘlv ne.het.e̞r re.sʌ ma.do.vɘn.de̞r.len.fɐt , les.ɐ —</textarea>
</label>
<label>
	<h2>Output</h2>
	<div id="output"></div>
</label>
<h2>Glyph Table</h2>
<div id="glyph-table" class="table-container"></div>
<script type="text/coffeescript">
	
	alphabet = "Dg97bdeifhjklmnoprstvxAEuVwaJP"
	alphabet_vowel_characters = "uaAevJioE"
	
	font_image = "url(font/barrish.png)"
	size = 144
	
	normalize = (text)->
		_text = ""
		for c in text
			_text += c unless c.charCodeAt(0) in [810, 865]
		_text
			.replace /p̪/g, "P" # pt
			.replace /pj/g, "7"
			.replace /\[p̪͡f\]|\[pf\]/g, "9" # pf
			.replace /\/dzh\//g, "D" # dzh
			.replace /\/ng\//g, "g" # ng
			.replace /ʉ/g, "u" # oo
			.replace /ɐ/g, "A"
			.replace /ʌ/g, "V" # uh
			.replace /\/ju\//g, "J" # ju
			.replace /e̞/g, "i" # ih
			.replace /ɘ/g, "E" # eh
			.replace /\s\./g, ";"
			.replace /!\s/g, "!"
			.replace /\.|·/g, "" # dots can separate syllables
	
	separate_gylphs = (text)->
		syllables = text.split(/\.|·/g)
		glyphs = []
		for syllable in syllables
			# cvc = c^c
			# cac = cc
			# cv = cv
			# vc = vc
			# cc = c^c
			# cvcc = c^c + c
			# cacc = cc + c
			# ccvc = c^c + vc
			# ccac = c^c + vc
			# ccvcc = c^c + vc + c
			# ccacc = c^c + vc + c
			# cccacc = ...
			
			# cvc
			# cc
			# cv
			# vc
			# v
			# c
			
			letters = normalize(syllable)
			
			letter_types = (
				for letter in letters
					if alphabet_vowel_characters.indexOf(letter) > 0
						"v"
					else
						"c"
			).join("")
			
			i = 0
			while i < letters.length
				length_remaining = letters.length - i - 1
				if length_remaining >= 2 and letter_types.substr(i, 3).match(/cvc/)
					glyphs.push(letters.substr(i, 3))
					i += 3
				else if length_remaining >= 1 and letter_types.substr(i, 2).match(/cc|cv|vc/)
					glyphs.push(letters.substr(i, 2))
					i += 2
				else if length_remaining >= 1
					glyphs.push(letters[i])
					i += 1
				else
					i += 1
		
		glyphs
	
	glyph_name_components = "Dzh Ᵹ P'f Pj B D Æ Ih F H J K L M N Oh P R S T V Xh Ah Eh Uu Uh W Ay Ju P'".split(" ")
	vowel_glyph_name_components = "Æ Ih Oh Ah Eh Uu Uh Ay Ju".split(" ")
	glyph_name_component_represents_vowel = (glyph_name_component)->
		vowel_glyph_name_components.indexOf(glyph_name_component) >= 0
	glyph_index_for_vowel_diacritic = (letter)->
		alphabet_vowel_characters.indexOf(letter)
	
	name_for_glyph_at = (x, y)->
		if y is 31
			"diacritic for vowel #{vowel_glyph_name_components[x]}"
		else
			"#{glyph_name_components[x]}" +
				if y is 0
					if glyph_name_component_represents_vowel(glyph_name_components[x])
						""
					else
						"a"
				else
					if glyph_name_component_represents_vowel(glyph_name_components[y - 1])
						"#{glyph_name_components[y - 1]?.toLowerCase()}"
					else
						"a#{glyph_name_components[y - 1]?.toLowerCase()}"
	
	# name_for_glyph_at = (x, y, diacritic)->
	# 	x_name = glyph_name_components[x]
	# 	y_name = glyph_name_components[y - 1]
	# 	name = x_name
	# 	
	# 	if y is 0
	# 		if glyph_name_component_represents_vowel(x_name)
	# 			""
	# 		else
	# 			diacritic ? "a"
	# 	else
	# 		unless y_name?
	# 			console.error x, y, diacritic, x_name, y_name
	# 		unless glyph_name_component_represents_vowel(y_name)
	# 			# if diacritic is "a" then "" else if diacritic? then diacritic else "a"
	# 			# name += "a"
	# 			name += diacritic ? "a"
	# 		name += y_name?.toLowerCase()
	# 		if diacritic is "a"
	# 			name += "a"
	# 	name
	
	render_glyph = (glyph, as_diacritic)->
		glyph_el = document.createElement("span")
		
		if glyph.length >= 3
			x = alphabet.indexOf(glyph[0])
			y = alphabet.indexOf(glyph[2]) + 1
			# console.log glyph[1]
			diacritic = glyph[1] # unless glyph[1] is "A"
		else if glyph.length >= 2
			x = alphabet.indexOf(glyph[0])
			y = alphabet.indexOf(glyph[1]) + 1
			# console.log glyph
			# diacritic = "t"
		else if as_diacritic
			# console.log glyph[0]
			x = glyph_index_for_vowel_diacritic(glyph[0])
			y = 31
		else
			x = alphabet.indexOf(glyph[0])
			y = 0
		
		glyph_el.style.backgroundImage = font_image
		glyph_el.style.backgroundPosition = "#{1 - x * size}px #{1 - y * size}px"
		glyph_el.style.display = "inline-block"
		glyph_el.style.width = "#{size}px"
		glyph_el.style.height = "#{size}px"
		glyph_el.style.zoom = "0.2" unless as_diacritic # this seems reversed
		glyph_el.title = name_for_glyph_at(x, y, diacritic)
		# glyph_el.title = "#{name_for_glyph_at(x, y)} (#{glyph})"
		
		if diacritic?
			diacritic_el = render_glyph(diacritic, yes)
			glyph_el.style.position = "relative"
			diacritic_el.style.position = "absolute"
			diacritic_el.style.top = "70%"
			diacritic_el.style.left = "0%"
			glyph_el.appendChild(diacritic_el)
		
		glyph_el
	
	render_barrish = (text, div)->
		div.innerHTML = ""
		words = text.split(" ")
		for word in words
			if word.match(/[!;]/)
				glyph_el = document.createElement("span")
				glyph_el.textContent = word
				div.appendChild(glyph_el)
			else
				for glyph in separate_gylphs(word)
					glyph_el = render_glyph(glyph)
					div.appendChild(glyph_el)
					glyph_el.setAttribute("data-glyph", glyph)
			glyph_el = document.createElement("span")
			glyph_el.textContent = " "
			div.appendChild(glyph_el)
	
	input = document.getElementById("input")
	output = document.getElementById("output")
	do input.onchange = input.oninput = input.onkeyup = ->
		render_barrish(input.value, output)
	
	$.get "lexicon.txt", (text)->
		words =
			for [word, definition] in colon_separated lines_of text
				word
		
		glyph_occurrences = {}
		
		for word in words
			for glyph in separate_gylphs(word)
				glyph_occurrences[glyph] ?= 0
				glyph_occurrences[glyph] += 1
		
		sortable_glyph_occurrences = []
		for glyph, occurrences of glyph_occurrences
			sortable_glyph_occurrences.push {glyph, occurrences}
		
		sortable_glyph_occurrences.sort (a, b)-> a.occurrences - b.occurrences
		
		# do make_glyph_occurrences_table = ->
		# 	table = document.createElement "table"
		# 	for {glyph, occurrences} in sortable_glyph_occurrences
		# 		tr = document.createElement "tr"
		# 		glyph_td = document.createElement "td"
		# 		occurrences_td = document.createElement "td"
		# 		glyph_td.textContent = glyph
		# 		occurrences_td.textContent = occurrences
		# 		tr.appendChild(glyph_td)
		# 		tr.appendChild(occurrences_td)
		# 		table.appendChild(tr)
		# 	document.body.appendChild(table)
		
		do make_glyph_table = ->
			table_container = document.getElementById("glyph-table")
			table = document.createElement("div")
			table.className = "table"
			table.style.position = "relative"
			table.style.width = "#{size * 30}px"
			table.style.height = "#{size * 32}px"
			for y in [0...32]
				for x in [0...30]
					glyph_el = document.createElement("div")
					glyph_el.style.backgroundImage = font_image
					glyph_el.style.backgroundPosition = "#{1 - x * size}px #{1 - y * size}px"
					glyph_el.style.position = "absolute"
					glyph_el.style.left = "#{x * size}px"
					glyph_el.style.top = "#{y * size}px"
					glyph_el.style.width = "#{size}px"
					glyph_el.style.height = "#{size}px"
					glyph_el.title = name_for_glyph_at(x, y)
					table.appendChild(glyph_el)
			table_container.appendChild(table)
			document.body.appendChild(table_container)

</script>
